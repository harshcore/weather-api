<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Phonk Multi-Location Weather Dashboard â€” Complete</title>

  <!-- Google fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Poppins:wght@300;500;700&display=swap" rel="stylesheet">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,#05010a 0%, #08030e 60%);
      color: #e8f3ff;
      min-height:100vh;
      display:flex;
      padding:18px;
      gap:18px;
    }

    /* two-column container */
    .container{
      width:100%;
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:18px;
      align-items:start;
    }
    @media (max-width:900px){
      .container{grid-template-columns:1fr; padding-bottom:18px}
    }

    /* left panel */
    .panel-left{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,0,160,0.02));
      border:1px solid rgba(255,0,160,0.06);
      border-radius:14px;
      padding:16px;
      min-height:calc(100vh - 36px);
      display:flex;
      flex-direction:column;
      gap:12px;
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      overflow:auto;
    }

    .brand {
      font-family: 'Orbitron', sans-serif;
      font-weight:700;
      color: #ff8bd8;
      letter-spacing:1px;
      font-size:1.15rem;
    }
    .subtitle { color:#9fb4d9; font-size:0.88rem; margin-top:4px }

    label.muted { color:#9fb4d9; font-size:0.85rem; display:block; margin-bottom:6px }

    .search-row { display:flex; gap:8px; align-items:center; margin-top:6px }
    .search-row input[type="text"], .coords input {
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.06);
      padding:10px 12px;
      color:#eaf2ff;
      border-radius:10px;
      outline:none;
      font-size:0.95rem;
    }
    .search-row button, .btn {
      background: linear-gradient(90deg,#ff007c,#00eaff);
      color:#03111a;
      padding:9px 12px;
      border-radius:10px;
      border:none;
      font-weight:700;
      cursor:pointer;
      font-size:0.95rem;
    }
    .btn.secondary {
      background: transparent;
      color: #d7eafe;
      border: 1px solid rgba(255,255,255,0.06);
      font-weight:600;
    }

    .suggestions {
      margin-top:8px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,0,160,0.06);
      border-radius:8px;
      max-height:240px;
      overflow:auto;
    }
    .suggestions .item {
      padding:10px;
      cursor:pointer;
      border-bottom:1px dashed rgba(255,255,255,0.02);
      color:#eaf2ff;
    }
    .suggestions .item:hover{ background: rgba(255,0,160,0.06); color:#001018 }

    .chips { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px }
    .chip {
      padding:8px 12px;
      border-radius:999px;
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.04);
      cursor:pointer;
      font-size:0.9rem;
    }
    .chip:hover{ transform:translateY(-4px); box-shadow: 0 18px 45px rgba(0,232,255,0.04) }

    .control-actions { display:flex; gap:8px; margin-top:12px }
    .muted { color:#9fb4d9; font-size:0.88rem }

    .recent-list {
      margin-top:12px;
      background: rgba(0,0,0,0.04);
      border-radius:8px;
      padding:8px;
      border: 1px dashed rgba(255,255,255,0.02);
    }
    .recent-item {
      display:flex; justify-content:space-between; gap:8px; align-items:center;
      padding:6px; border-radius:6px;
    }
    .recent-item .label { color:#eaf2ff; font-size:0.92rem; }
    .recent-item .actions { display:flex; gap:6px; align-items:center; }
    .mini-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      color:#d7eafe;
      padding:6px 8px;
      border-radius:6px;
      cursor:pointer;
      font-size:0.82rem;
    }
    .mini-btn.danger { border-color: rgba(255,0,70,0.12); color: #ff9fb4; }

    footer.storage {
      margin-top:auto;
      font-size:0.82rem;
      color:#9fb4d9;
      border-top:1px dashed rgba(255,255,255,0.02);
      padding-top:10px;
    }

    /* right panel */
    .panel-right{
      background: linear-gradient(180deg, rgba(10,6,20,0.55), rgba(3,6,12,0.75));
      border: 1px solid rgba(0,200,255,0.03);
      border-radius: 14px;
      padding: 14px;
      min-height: calc(100vh - 36px);
      overflow:auto;
      box-shadow: 0 10px 40px rgba(1,2,6,0.75);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .toolbar {
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      margin-bottom:6px;
    }
    .grid {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap:12px;
    }

    .location-card {
      border-radius:12px;
      padding:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,0,160,0.02));
      border:1px solid rgba(255,0,160,0.04);
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:8px;
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .location-card:hover{ transform: translateY(-6px); box-shadow: 0 22px 45px rgba(0,0,0,0.6) }

    .card-header { display:flex; justify-content:space-between; align-items:center }
    .loc-name { font-weight:700; color:#ffd3f0; font-size:1.05rem }
    .loc-coords { font-size:0.85rem; color:#9fb4d9 }

    .small-grid {
      display:grid; grid-template-columns:1fr 1fr; gap:.35rem .8rem; align-items:center; margin-top:6px;
    }
    .kv { display:flex; flex-direction:column; gap:.18rem }
    .k { font-size:.78rem; color:#9fb4d9 }
    .v { font-weight:700; font-size:1rem; color:#e8f6ff }

    .aqi-pill { padding:6px 10px; border-radius:999px; font-weight:700; font-size:0.92rem; display:inline-block }
    .aqi-good{ background: rgba(0,255,153,0.12); color:#00ff99; border:1px solid rgba(0,255,153,0.12) }
    .aqi-moderate{ background: rgba(255,255,0,0.08); color:#fff200; border:1px solid rgba(255,255,0,0.06) }
    .aqi-unhealthy{ background: rgba(255,120,0,0.08); color:#ff7b00; border:1px solid rgba(255,120,0,0.06) }
    .aqi-hazardous{ background: rgba(255,0,70,0.08); color:#ff1244; border:1px solid rgba(255,0,70,0.06) }

    .card-actions { display:flex; gap:8px; margin-top:6px; }
    .icon-btn { background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); padding:8px 10px; border-radius:8px; cursor:pointer; color:#eef8ff; font-weight:600 }

    .loader { font-size:0.95rem; color:#9fb4d9 }

    .empty { color:#9fb4d9; text-align:center; padding: 28px 0; border:1px dashed rgba(255,255,255,0.03); border-radius:8px }

    /* sparkline fixed size â€” prevents stretching */
    .spark-canvas {
      width:160px;
      height:48px;
      display:block;
    }
    /* main hourly chart fixed height */
    #mainHourlyChart {
      width:100%;
      height:220px;
      display:block;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- LEFT CONTROLS -->
    <aside class="panel-left" aria-label="controls">
      <div>
        <div class="brand">PHONK ATMOS</div>
        <div class="subtitle">Multi-location weather + AQI â€¢ saved locally</div>

        <div style="margin-top:14px">
          <label class="muted">Search city (type â†’ pick)</label>
          <div class="search-row">
            <input id="searchInput" type="text" placeholder="Tokyo, Mumbai, New York..." autocomplete="off" />
            <button id="searchClear" class="btn secondary" title="Clear search">X</button>
          </div>
          <div id="suggestions" class="suggestions" style="display:none;margin-top:8px"></div>
        </div>

        <div style="margin-top:12px">
          <label class="muted">Add by coordinates</label>
          <div class="coords" style="display:flex;gap:8px;margin-top:6px">
            <input id="latInput" type="number" step="any" placeholder="Latitude" />
            <input id="lonInput" type="number" step="any" placeholder="Longitude" />
            <button id="addCoordsBtn" class="btn">Add</button>
          </div>
        </div>

        <div style="margin-top:12px">
          <label class="muted">Quick selects</label>
          <div id="quickChips" class="chips" style="margin-top:8px">
            <div class="chip" data-lat="51.5072" data-lon="-0.1276">London</div>
            <div class="chip" data-lat="40.7128" data-lon="-74.0060">New York</div>
            <div class="chip" data-lat="35.6762" data-lon="139.6503">Tokyo</div>
            <div class="chip" data-lat="28.6139" data-lon="77.2090">Delhi</div>
            <div class="chip" data-lat="37.7749" data-lon="-122.4194">San Francisco</div>
          </div>
        </div>

        <div style="margin-top:12px">
          <label class="muted">Actions</label>
          <div class="control-actions" style="margin-top:8px">
            <button id="updateAllBtn" class="btn">Refresh All</button>
            <button id="clearAllBtn" class="btn secondary">Clear All</button>
          </div>
        </div>

        <div style="margin-top:12px">
          <label class="muted">Recent (removed)</label>
          <div class="recent-list" id="recentList">
            <!-- recent items inserted here -->
            <div class="muted" style="padding:8px">No recent items</div>
          </div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="clearRecentBtn" class="mini-btn">Clear Recent</button>
            <button id="addMyLocationBtn" class="mini-btn">Add my location</button>
          </div>
        </div>

      </div>

      <footer class="storage">
        <div>Saved locally â€” this browser.</div>
        <div style="margin-top:6px; font-size:0.82rem;">Tip: allow location when prompted to auto-add your current spot.</div>
      </footer>
    </aside>

    <!-- RIGHT DASHBOARD -->
    <main class="panel-right" aria-label="dashboard">
      <div class="toolbar">
        <div class="left">
          <div style="font-weight:700; color:#a9e9ff">Locations</div>
          <div style="margin-left:10px; color:#9fb4d9; font-size:0.92rem">Live weather & AQI</div>
        </div>
        <div class="right">
          <div id="status" class="loader">Idle</div>
        </div>
      </div>

      <section id="gridArea" class="grid"></section>

      <div id="emptyNotice" class="empty" style="display:none; margin-top:6px">
        No locations yet â€” add a city or coordinates on the left.
      </div>

      <div class="card" style="margin-top:8px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Hourly temperature (selected)</div>
          <div id="selectedLabel" style="color:#9fb4d9;font-size:0.9rem">â€”</div>
        </div>
        <canvas id="mainHourlyChart"></canvas>
      </div>
    </main>
  </div>

  <script>
    /**************************************************************************
     * Full working dashboard with RECENT functionality & "Add my location"
     *
     * New additions:
     * - When a saved location is removed it moves to the RECENT list (localStorage)
     * - Recent list is shown in left panel, click to add back to saved locations
     * - Remove individual recent items or clear all recent items
     * - "Add my location" button to add current geolocation if not already present
     *
     * Original behaviors preserved.
     **************************************************************************/

    const STORAGE_KEY = 'phonk_locations_v2';
    const RECENT_KEY = 'phonk_recent_v1';
    const MAX_RECENT = 30;

    let locations = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); // { id, name, lat, lon, data, hourly, lastUpdated }
    let recent = JSON.parse(localStorage.getItem(RECENT_KEY) || '[]'); // array of { id, name, lat, lon, data, hourly, removedAt }

    const gridArea = document.getElementById('gridArea');
    const emptyNotice = document.getElementById('emptyNotice');
    const status = document.getElementById('status');

    const searchInput = document.getElementById('searchInput');
    const suggestionsEl = document.getElementById('suggestions');
    const searchClear = document.getElementById('searchClear');

    const latInput = document.getElementById('latInput');
    const lonInput = document.getElementById('lonInput');
    const addCoordsBtn = document.getElementById('addCoordsBtn');

    const updateAllBtn = document.getElementById('updateAllBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');

    const recentListEl = document.getElementById('recentList');
    const clearRecentBtn = document.getElementById('clearRecentBtn');
    const addMyLocationBtn = document.getElementById('addMyLocationBtn');

    const selectedLabel = document.getElementById('selectedLabel');
    const mainHourlyCanvas = document.getElementById('mainHourlyChart');

    // store chart instances
    const cardCharts = new Map();
    let mainChart = null;
    let selectedLocationIndex = 0; // index in locations[] used for main hourly chart

    // helper uid
    const uid = () => 'loc_' + Math.random().toString(36).slice(2,9);

    function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }
    function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(locations)); }
    function saveRecent(){ localStorage.setItem(RECENT_KEY, JSON.stringify(recent)); }

    // AQI helpers
    function aqiClassFromNumber(n){
      if (n === null || isNaN(n)) return '';
      if (n <= 50) return 'aqi-good';
      if (n <= 100) return 'aqi-moderate';
      if (n <= 150) return 'aqi-unhealthy';
      return 'aqi-hazardous';
    }
    function aqiLabelFromNumber(n){
      if (n === null || isNaN(n)) return 'N/A';
      if (n <= 50) return 'Good';
      if (n <= 100) return 'Moderate';
      if (n <= 150) return 'Unhealthy';
      return 'Hazardous';
    }

    // API calls
    async function fetchWeather(lat, lon){
      const weatherURL = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,apparent_temperature&timezone=auto`;
      const res = await fetch(weatherURL);
      if (!res.ok) throw new Error('Weather API error: ' + res.status);
      return await res.json();
    }
    async function fetchAqi(lat, lon){
      const aqiURL = `https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${lat}&longitude=${lon}&hourly=us_aqi&timezone=auto`;
      const res = await fetch(aqiURL);
      if (!res.ok) throw new Error('AQI API error: ' + res.status);
      return await res.json();
    }

    // geocoding suggestions (debounced)
    let geoReq = 0;
    async function geocodeQuery(q){
      const thisReq = ++geoReq;
      if (!q || q.length < 2){ suggestionsEl.style.display='none'; suggestionsEl.innerHTML=''; return; }
      suggestionsEl.style.display='block';
      suggestionsEl.innerHTML = `<div class="item">Searchingâ€¦</div>`;
      try {
        const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(q)}&count=8&language=en`;
        const r = await fetch(url);
        const json = await r.json();
        if (thisReq !== geoReq) return; // stale
        if (!json || !Array.isArray(json.results) || json.results.length === 0){
          suggestionsEl.innerHTML = `<div class="item">No results</div>`;
          return;
        }
        suggestionsEl.innerHTML = json.results.map(r => {
          const label = `${r.name}${r.admin1 ? ', '+r.admin1 : ''}${r.country ? ', '+r.country : ''}`;
          const safe = escapeHtml(label);
          return `<div class="item" data-lat="${r.latitude}" data-lon="${r.longitude}" data-name="${safe}">${safe}</div>`;
        }).join('');
      } catch(e){
        console.warn('geocode', e);
        suggestionsEl.innerHTML = `<div class="item">Error</div>`;
      }
    }

    // rendering
    function updateEmptyState(){ emptyNotice.style.display = locations.length === 0 ? 'block' : 'none'; }

    function destroyAllCardCharts(){
      for (const c of cardCharts.values()){
        try { c.destroy(); } catch(e) {}
      }
      cardCharts.clear();
    }
    function destroyMainChart(){ if (mainChart){ try{ mainChart.destroy(); }catch(e){} mainChart = null; } }

    function renderRecent(){
      recentListEl.innerHTML = '';
      if (!recent || recent.length === 0){
        recentListEl.innerHTML = `<div class="muted" style="padding:8px">No recent items</div>`;
        return;
      }
      // show most-recent-first
      recent.slice().reverse().forEach((r, idxReverse) => {
        const idx = recent.length - 1 - idxReverse; // actual index in recent array
        const div = document.createElement('div');
        div.className = 'recent-item';
        div.innerHTML = `
          <div class="label">${escapeHtml(r.name || `${r.lat.toFixed(3)}, ${r.lon.toFixed(3)}`)}</div>
          <div class="actions">
            <button class="mini-btn" data-action="add" data-idx="${idx}">Add</button>
            <button class="mini-btn danger" data-action="remove" data-idx="${idx}">Delete</button>
          </div>
        `;
        // actions
        div.querySelector('[data-action="add"]').addEventListener('click', () => {
          // add back to locations (if not duplicate)
          const item = recent[idx];
          if (!item) return;
          const duplicate = locations.some(l => Math.abs(l.lat - item.lat) < 0.1 && Math.abs(l.lon - item.lon) < 0.1);
          if (duplicate){ alert('Location already in dashboard'); return; }
          // move item back to locations (with new id)
          const newEntry = {
            id: uid(),
            name: item.name,
            lat: item.lat,
            lon: item.lon,
            data: item.data || {},
            hourly: item.hourly || null,
            lastUpdated: Date.now()
          };
          locations.push(newEntry);
          saveState();
          // remove from recent
          recent.splice(idx,1);
          saveRecent();
          render();
          renderRecent();
        });
        div.querySelector('[data-action="remove"]').addEventListener('click', () => {
          if (!confirm(`Remove recent '${recent[idx].name}'?`)) return;
          recent.splice(idx,1);
          saveRecent();
          renderRecent();
        });
        recentListEl.appendChild(div);
      });
    }

    function render(){
      gridArea.innerHTML = '';
      destroyAllCardCharts();

      if (locations.length === 0){
        updateEmptyState();
        status.textContent = 'No locations';
        selectedLabel.textContent = 'â€”';
        destroyMainChart();
        return;
      }
      updateEmptyState();
      status.textContent = `Showing ${locations.length} location(s)`;

      // clamp selected index
      if (selectedLocationIndex >= locations.length) selectedLocationIndex = 0;

      locations.forEach((loc, idx) => {
        const data = loc.data || {};
        const hourly = loc.hourly || {};
        const aqiNum = (data.aqi === undefined || data.aqi === null) ? null : Number(data.aqi);
        const aqiClass = aqiClassFromNumber(aqiNum);
        const aqiLabel = aqiLabelFromNumber(aqiNum);
        const updated = loc.lastUpdated ? new Date(loc.lastUpdated).toLocaleString() : 'â€”';

        const card = document.createElement('article');
        card.className = 'location-card';
        card.innerHTML = `
          <div class="card-header">
            <div>
              <div class="loc-name">${escapeHtml(loc.name || 'Unknown')}</div>
              <div class="loc-coords">${Number(loc.lat).toFixed(4)}, ${Number(loc.lon).toFixed(4)}</div>
            </div>
            <div style="text-align:right;min-width:120px">
              <div style="margin-top:6px; display:flex; gap:8px; justify-content:flex-end">
                <button class="icon-btn" data-action="refresh" title="Refresh">â†»</button>
                <button class="icon-btn" data-action="remove" title="Remove">ðŸ—‘</button>
              </div>
            </div>
          </div>

          <div class="small-grid" style="margin-top:8px">
            <div class="kv"><div class="k">Temperature</div><div class="v">${data.temp !== undefined && data.temp !== null ? `${data.temp} Â°C` : 'â€”'}</div></div>
            <div class="kv"><div class="k">Feels</div><div class="v">${data.feels !== undefined && data.feels !== null ? `${data.feels} Â°C` : 'â€”'}</div></div>

            <div class="kv"><div class="k">Humidity</div><div class="v">${data.humidity !== undefined && data.humidity !== null ? `${data.humidity} %` : 'â€”'}</div></div>
            <div class="kv"><div class="k">Wind</div><div class="v">${data.wind !== undefined && data.wind !== null ? `${data.wind} km/h` : 'â€”'}</div></div>

            <div class="kv"><div class="k">Cloud</div><div class="v">${data.cloud !== undefined && data.cloud !== null ? `${data.cloud} %` : 'â€”'}</div></div>
            <div class="kv"><div class="k">Pressure</div><div class="v">${data.pressure !== undefined && data.pressure !== null ? `${data.pressure} hPa` : 'â€”'}</div></div>
          </div>

          <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px">
            <div>
              <div class="k">AQI</div>
              <div style="margin-top:6px">
                <span class="aqi-pill ${aqiClass}">${aqiNum === null || isNaN(aqiNum) ? 'N/A' : aqiNum} ${aqiNum !== null && !isNaN(aqiNum) ? `Â· ${aqiLabel}` : ''}</span>
              </div>
            </div>

            <div style="text-align:right">
              <div class="k">Day/Night</div>
              <div class="v">${data.is_day === 1 ? 'Day' : (data.is_day === 0 ? 'Night' : 'â€”')}</div>
            </div>
          </div>

          <div style="display:flex; justify-content:space-between;align-items:center;margin-top:8px">
            <div style="flex:1">
              <div class="k">Hourly temps</div>
              <canvas id="spark_${loc.id}" class="spark-canvas"></canvas>
            </div>
            <div style="width:1px"></div>
          </div>
        `;

        // click main select when clicking card header (so main chart shows this loc)
        card.querySelector('.card-header').addEventListener('click', () => {
          selectedLocationIndex = idx;
          updateMainHourlyChart();
        });

        // actions
        const refreshBtn = card.querySelector('[data-action="refresh"]');
        const removeBtn = card.querySelector('[data-action="remove"]');
        refreshBtn.addEventListener('click', (ev) => { ev.stopPropagation(); refreshLocation(idx); });
        removeBtn.addEventListener('click', (ev) => { ev.stopPropagation(); removeLocationToRecent(idx); });

        gridArea.appendChild(card);

        // render sparkline safely (fixed height)
        if (hourly && Array.isArray(hourly.time) && Array.isArray(hourly.temperature_2m)){
          try {
            const canvas = document.getElementById(`spark_${loc.id}`);
            // ensure fixed pixel height to prevent Chart.js from resizing weirdly
            canvas.width = 160;
            canvas.height = 48;
            const ctx = canvas.getContext('2d');
            const labels = hourly.time.slice(0, 24).map(t => t.replace('T',' ').slice(11,16));
            const temps = hourly.temperature_2m.slice(0, 24);
            const spark = new Chart(ctx, {
              type: 'line',
              data: { labels, datasets: [{ data: temps, fill:true, tension:0.25, pointRadius:0, borderWidth:1 }] },
              options: {
                responsive: false, // important: false for fixed canvas size
                plugins:{ legend:{ display:false } },
                scales: { x:{ display:false }, y:{ display:false } },
                elements:{ line:{ backgroundColor:'rgba(255,0,153,0.12)', borderColor:'rgba(255,0,153,0.9)' } }
              }
            });
            cardCharts.set(loc.id, spark);
          } catch(e){ console.warn('sparkline err', e); }
        }
      }); // end forEach

      // after rendering cards, update main chart for selected location
      updateMainHourlyChart();
    }

    // move removed location to recent list (instead of permanent delete)
    function removeLocationToRecent(index){
      const item = locations[index];
      if (!item) return;
      if (!confirm(`Remove ${item.name || 'this location'} and move to recent?`)) return;

      // prepare recent entry (shallow copy)
      const recentEntry = {
        id: item.id, // keep original id for reference (but we will not reuse)
        name: item.name,
        lat: item.lat,
        lon: item.lon,
        data: item.data || {},
        hourly: item.hourly || null,
        removedAt: Date.now()
      };

      // remove from locations
      // destroy chart if present
      if (cardCharts.has(item.id)){ try{ cardCharts.get(item.id).destroy(); }catch(e){} cardCharts.delete(item.id); }

      locations.splice(index,1);
      saveState();

      // push to recent while preventing duplicates (by lat/lon within 0.1)
      const dupIndex = recent.findIndex(r => Math.abs(r.lat - recentEntry.lat) < 0.1 && Math.abs(r.lon - recentEntry.lon) < 0.1);
      if (dupIndex !== -1){
        // update removedAt and place as most recent
        recent.splice(dupIndex,1);
      }
      recent.push(recentEntry);
      // cap recent length
      if (recent.length > MAX_RECENT) recent = recent.slice(recent.length - MAX_RECENT);
      saveRecent();
      render();
      renderRecent();
      status.textContent = `Moved ${item.name} to recent`;
      setTimeout(()=> status.textContent = `Showing ${locations.length} location(s)`, 800);
    }

    // permanently remove from recent
    function removeRecentAt(idx){
      if (idx < 0 || idx >= recent.length) return;
      recent.splice(idx,1);
      saveRecent();
      renderRecent();
    }

    // clear all recent
    function clearAllRecent(){
      if (!confirm('Clear all recent items?')) return;
      recent = [];
      saveRecent();
      renderRecent();
    }

    // add current user location via geolocation (button)
    async function addMyLocationButtonAction(){
      if (!navigator.geolocation) { alert('Geolocation not supported'); return; }
      // check duplicate: we will check later after obtaining coords
      status.textContent = 'Getting your location...';
      navigator.geolocation.getCurrentPosition(async (pos) => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        const duplicate = locations.some(l => Math.abs(l.lat - lat) < 0.1 && Math.abs(l.lon - lon) < 0.1);
        if (duplicate) { alert('Your location is already in the dashboard'); status.textContent = `Showing ${locations.length} location(s)`; return; }
        try {
          await addLocation(lat, lon, 'My Location');
          status.textContent = 'Added your location';
        } catch(e){
          console.warn('add my location failed', e);
          alert('Failed to add your location');
        } finally {
          setTimeout(()=> status.textContent = `Showing ${locations.length} location(s)`, 700);
        }
      }, (err) => {
        console.warn('geolocation error', err);
        alert('Could not retrieve location (permission denied or error)');
        status.textContent = `Showing ${locations.length} location(s)`;
      }, { enableHighAccuracy:false, timeout:8000 });
    }

    // CRUD operations
    async function addLocation(lat, lon, name){
      status.textContent = 'Adding...';
      try {
        const [wJson, aJson] = await Promise.all([
          fetchWeather(lat, lon).catch(()=>null),
          fetchAqi(lat, lon).catch(()=>null)
        ]);

        const wCur = wJson && wJson.current_weather ? wJson.current_weather : null;
        const hourly = wJson && wJson.hourly ? wJson.hourly : null;
        const aqiVal = aJson && aJson.hourly && Array.isArray(aJson.hourly.us_aqi) && aJson.hourly.us_aqi.length ? aJson.hourly.us_aqi[aJson.hourly.us_aqi.length - 1] : null;

        const data = {
          temp: wCur?.temperature ?? null,
          feels: wJson?.hourly?.apparent_temperature ? wJson.hourly.apparent_temperature[0] ?? null : (wCur?.temperature ?? null),
          is_day: (wCur?.is_day !== undefined ? wCur.is_day : null),
          wind: wCur?.windspeed ?? null,
          pressure: wJson?.surface_pressure ?? null,
          cloud: wJson?.cloudcover ?? null,
          humidity: wJson?.relativehumidity_2m ?? null,
          dew: wJson?.dew_point_2m ?? null,
          aqi: (aqiVal === undefined ? null : (aqiVal === null ? null : Number(aqiVal)))
        };

        const entry = {
          id: uid(),
          name: name || `${Number(lat).toFixed(3)}, ${Number(lon).toFixed(3)}`,
          lat: Number(lat),
          lon: Number(lon),
          data,
          hourly,
          lastUpdated: Date.now()
        };

        locations.push(entry);
        saveState();
        render();
        status.textContent = 'Added';
      } catch (err){
        console.error(err);
        status.textContent = 'Add failed';
        alert('Failed to add location: ' + (err.message || err));
      } finally {
        setTimeout(()=> status.textContent = `Showing ${locations.length} location(s)`, 600);
      }
    }

    async function refreshLocation(index){
      const loc = locations[index];
      if (!loc) return;
      status.textContent = `Refreshing ${loc.name}...`;
      try {
        const [wJson, aJson] = await Promise.all([
          fetchWeather(loc.lat, loc.lon).catch(()=>null),
          fetchAqi(loc.lat, loc.lon).catch(()=>null)
        ]);
        const wCur = wJson && wJson.current_weather ? wJson.current_weather : null;
        const hourly = wJson && wJson.hourly ? wJson.hourly : null;
        const aqiVal = aJson && aJson.hourly && Array.isArray(aJson.hourly.us_aqi) && aJson.hourly.us_aqi.length ? aJson.hourly.us_aqi[aJson.hourly.us_aqi.length - 1] : null;

        const data = {
          temp: wCur?.temperature ?? null,
          feels: wJson?.hourly?.apparent_temperature ? wJson.hourly.apparent_temperature[0] ?? null : (wCur?.temperature ?? null),
          is_day: (wCur?.is_day !== undefined ? wCur.is_day : null),
          wind: wCur?.windspeed ?? null,
          pressure: wJson?.surface_pressure ?? null,
          cloud: wJson?.cloudcover ?? null,
          humidity: wJson?.relativehumidity_2m ?? null,
          dew: wJson?.dew_point_2m ?? null,
          aqi: (aqiVal === undefined ? null : (aqiVal === null ? null : Number(aqiVal)))
        };

        locations[index].data = data;
        locations[index].hourly = hourly;
        locations[index].lastUpdated = Date.now();
        saveState();
        render();
        status.textContent = `Refreshed ${loc.name}`;
      } catch (err){
        console.error(err);
        status.textContent = 'Refresh failed';
        alert('Failed to refresh: ' + (err.message || err));
      } finally {
        setTimeout(()=> status.textContent = `Showing ${locations.length} location(s)`, 600);
      }
    }

    async function refreshAll(){
      if (locations.length === 0) return;
      status.textContent = 'Refreshing all...';
      for (let i=0;i<locations.length;i++){
        try {
          const loc = locations[i];
          const [wJson, aJson] = await Promise.all([
            fetchWeather(loc.lat, loc.lon).catch(()=>null),
            fetchAqi(loc.lat, loc.lon).catch(()=>null)
          ]);
          const wCur = wJson && wJson.current_weather ? wJson.current_weather : null;
          const hourly = wJson && wJson.hourly ? wJson.hourly : null;
          const aqiVal = aJson && aJson.hourly && Array.isArray(aJson.hourly.us_aqi) && aJson.hourly.us_aqi.length ? aJson.hourly.us_aqi[aJson.hourly.us_aqi.length - 1] : null;

          const data = {
            temp: wCur?.temperature ?? null,
            feels: wJson?.hourly?.apparent_temperature ? wJson.hourly.apparent_temperature[0] ?? null : (wCur?.temperature ?? null),
            is_day: (wCur?.is_day !== undefined ? wCur.is_day : null),
            wind: wCur?.windspeed ?? null,
            pressure: wJson?.surface_pressure ?? null,
            cloud: wJson?.cloudcover ?? null,
            humidity: wJson?.relativehumidity_2m ?? null,
            dew: wJson?.dew_point_2m ?? null,
            aqi: (aqiVal === undefined ? null : (aqiVal === null ? null : Number(aqiVal)))
          };
          locations[i].data = data;
          locations[i].hourly = hourly;
          locations[i].lastUpdated = Date.now();
        } catch(e){
          console.warn('refresh error for index', i, e);
        }
      }
      saveState();
      render();
      status.textContent = 'All refreshed';
      setTimeout(()=> status.textContent = `Showing ${locations.length} location(s)`, 800);
    }

    function removeLocation(index){
      // legacy direct delete (keeps behavior but also support move-to-recent)
      const name = locations[index]?.name || 'item';
      if (!confirm(`Remove ${name}?`)) return;
      const id = locations[index].id;
      if (cardCharts.has(id)){ try{ cardCharts.get(id).destroy(); }catch(e){} cardCharts.delete(id); }
      locations.splice(index,1);
      saveState();
      render();
      status.textContent = `Removed ${name}`;
      setTimeout(()=> status.textContent = `Showing ${locations.length} location(s)`, 800);
    }

    function clearAll(){
      if (!confirm('Remove all saved locations?')) return;
      destroyAllCardCharts();
      destroyMainChart();
      locations = [];
      saveState();
      render();
      status.textContent = 'Cleared';
    }

    // UI interactions
    let suggestionTimeout = null;
    searchInput.addEventListener('input', (e) => {
      const q = (e.target.value || '').trim();
      if (suggestionTimeout) clearTimeout(suggestionTimeout);
      if (!q){ suggestionsEl.style.display='none'; suggestionsEl.innerHTML=''; return; }
      suggestionTimeout = setTimeout(()=> geocodeQuery(q), 300);
    });
    searchClear.addEventListener('click', ()=> { searchInput.value=''; suggestionsEl.style.display='none'; suggestionsEl.innerHTML=''; });

    suggestionsEl.addEventListener('click', (ev) => {
      const item = ev.target.closest('.item');
      if (!item) return;
      const lat = Number(item.dataset.lat);
      const lon = Number(item.dataset.lon);
      const name = item.dataset.name || item.textContent;
      suggestionsEl.style.display='none';
      searchInput.value = '';
      // avoid duplicates within ~10km
      const duplicate = locations.some(l => Math.abs(l.lat - lat) < 0.1 && Math.abs(l.lon - lon) < 0.1);
      if (duplicate) { alert('Location already added'); return; }
      addLocation(lat, lon, name);
    });

    addCoordsBtn.addEventListener('click', () => {
      const lat = Number(latInput.value);
      const lon = Number(lonInput.value);
      if (isNaN(lat) || isNaN(lon)){ alert('Enter valid numbers for lat & lon'); return; }
      const duplicate = locations.some(l => Math.abs(l.lat - lat) < 0.1 && Math.abs(l.lon - lon) < 0.1);
      if (duplicate) { alert('Location already added'); latInput.value=''; lonInput.value=''; return; }
      addLocation(lat, lon, `Coords: ${lat.toFixed(3)}, ${lon.toFixed(3)}`);
      latInput.value=''; lonInput.value='';
    });

    document.getElementById('quickChips').addEventListener('click', (ev) => {
      const chip = ev.target.closest('.chip');
      if (!chip) return;
      const lat = Number(chip.dataset.lat);
      const lon = Number(chip.dataset.lon);
      const name = chip.textContent.trim();
      const duplicate = locations.some(l => Math.abs(l.lat - lat) < 0.1 && Math.abs(l.lon - lon) < 0.1);
      if (duplicate) { alert('Location already added'); return; }
      addLocation(lat, lon, name);
    });

    updateAllBtn.addEventListener('click', refreshAll);
    clearAllBtn.addEventListener('click', clearAll);

    document.addEventListener('click', (ev) => {
      if (!ev.target.closest('#suggestions') && !ev.target.closest('#searchInput')) suggestionsEl.style.display='none';
    });

    clearRecentBtn.addEventListener('click', clearAllRecent);
    addMyLocationBtn.addEventListener('click', addMyLocationButtonAction);

    // initial + geolocation auto-add (if allowed)
    async function init(){
      render();
      renderRecent();

      // refresh saved on startup
      if (locations.length > 0){
        status.textContent = 'Refreshing saved locations...';
        await refreshAll();
      }

      // try to add user location (if not duplicate)
      if (navigator.geolocation){
        navigator.geolocation.getCurrentPosition(async (pos) => {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const duplicate = locations.some(l => Math.abs(l.lat - lat) < 0.1 && Math.abs(l.lon - lon) < 0.1);
          if (!duplicate){
            try {
              const [wJson, aJson] = await Promise.all([fetchWeather(lat, lon).catch(()=>null), fetchAqi(lat, lon).catch(()=>null)]);
              const wCur = wJson && wJson.current_weather ? wJson.current_weather : null;
              const hourly = wJson && wJson.hourly ? wJson.hourly : null;
              const aqiVal = aJson && aJson.hourly && Array.isArray(aJson.hourly.us_aqi) && aJson.hourly.us_aqi.length ? aJson.hourly.us_aqi[aJson.hourly.us_aqi.length - 1] : null;
              const data = {
                temp: wCur?.temperature ?? null,
                feels: wJson?.hourly?.apparent_temperature ? wJson.hourly.apparent_temperature[0] ?? null : (wCur?.temperature ?? null),
                is_day: (wCur?.is_day !== undefined ? wCur.is_day : null),
                wind: wCur?.windspeed ?? null,
                pressure: wJson?.surface_pressure ?? null,
                cloud: wJson?.cloudcover ?? null,
                humidity: wJson?.relativehumidity_2m ?? null,
                dew: wJson?.dew_point_2m ?? null,
                aqi: (aqiVal === undefined ? null : (aqiVal === null ? null : Number(aqiVal)))
              };
              const entry = {
                id: uid(),
                name: 'My Location',
                lat, lon,
                data,
                hourly,
                lastUpdated: Date.now()
              };
              locations.unshift(entry);
              saveState();
              render();
              status.textContent = 'Added your location';
              setTimeout(()=> status.textContent = `Showing ${locations.length} location(s)`, 900);
            } catch(e){
              console.warn('user location add failed', e);
            }
          }
        }, (err) => {
          console.warn('geolocation error', err);
        }, { enableHighAccuracy:false, timeout:5000 });
      }
    }

    // main hourly chart update (for selected location)
    function updateMainHourlyChart(){
      destroyMainChart();
      if (locations.length === 0){ selectedLabel.textContent = 'â€”'; return; }
      const loc = locations[selectedLocationIndex];
      selectedLabel.textContent = loc.name;
      const hourly = loc.hourly;
      if (!hourly || !Array.isArray(hourly.time) || !Array.isArray(hourly.temperature_2m)){
        // nothing to show
        selectedLabel.textContent = loc.name + ' Â· no hourly data';
        return;
      }

      // set fixed size for main canvas to avoid weird resize
      mainHourlyCanvas.width = mainHourlyCanvas.clientWidth;
      mainHourlyCanvas.height = 220;

      const ctx = mainHourlyCanvas.getContext('2d');
      const labels = hourly.time.slice(0, 48).map(t => t.replace('T',' ').slice(11,16));
      const temps = hourly.temperature_2m.slice(0, 48);

      mainChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [{
            label: `${loc.name} Â· Temp (Â°C)`,
            data: temps,
            tension: 0.25,
            fill: true,
            borderColor: 'rgba(255,0,153,0.95)',
            backgroundColor: 'rgba(255,0,153,0.12)',
            pointRadius: 0
          }]
        },
        options: {
          responsive: false, // canvas has fixed pixel height
          plugins: { legend: { display: true, labels: { color: '#fff' } } },
          scales: {
            x: { ticks: { color: '#9fb4d9' } },
            y: { ticks: { color: '#9fb4d9' } }
          }
        }
      });
    }

    // Start
    init();

  </script>
</body>
</html>
